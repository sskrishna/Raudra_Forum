<?php
/**
 *
 * License, TERMS and CONDITIONS
 *
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE (LGPL) version 3
 * Please read the license here : http://www.gnu.org/licenses/lgpl-3.0.txt
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * ATTRIBUTION REQUIRED
 * 4. All web pages generated by the use of this software, or at least
 *       the page that lists the recent questions (usually home page) must include
 *    a link to the http://www.lampcms.com and text of the link must indicate that
 *    the website's Questions/Answers functionality is powered by lampcms.com
 *    An example of acceptable link would be "Powered by <a href="http://www.lampcms.com">LampCMS</a>"
 *    The location of the link is not important, it can be in the footer of the page
 *    but it must not be hidden by style attributes
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE FREEBSD PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This product includes GeoLite data created by MaxMind,
 *  available from http://www.maxmind.com/
 *
 *
 * @author     Dmitri Snytkine <cms@lampcms.com>
 * @copyright  2005-2012 (or current year) Dmitri Snytkine
 * @license    http://www.gnu.org/licenses/lgpl-3.0.txt GNU LESSER GENERAL PUBLIC LICENSE (LGPL) version 3
 * @link       http://www.lampcms.com   Lampcms.com project
 * @version    Release: 0.2.45
 *
 *
 */


namespace Lampcms;

use Lampcms\Mongo\Schema\Answer as Schema;
use Lampcms\String\HTMLStringParser;

/**
 * Class responsible for parsing submitted
 * answer object.
 * It will create new record in ANSWERS collection,
 * update QUESTIONS collection to increase answer count
 * of parent question, update UNANSWERED_TAGS collection,
 * update user's answers count
 * post event onNewAnswer
 *
 * @author Dmitri Snytkine
 *
 */
class Answerparser extends LampcmsObject
{

    /**
     * Object of type SubmittedAnswer
     * (or any sub-class of it)
     *
     * @var Object SubmittedAnswer
     */
    protected $SubmittedAnswer;


    /**
     * Object represents question for which
     * we are processing the answer
     *
     * @var object of type Question
     */
    protected $Question;


    /**
     * Cache object
     *
     * @var object of type \Lampcms\Cache\Cache
     */
    protected $Cache;


    /**
     * Object of newly created answer
     * an object of type Answer represents one
     * answer and is a MongoDoc object
     *
     * @var object of type Answer (extends \Lampcms\Mongo\Doc object)
     */
    protected $Answer = null;


    public function __construct(Registry $Registry)
    {
        $this->Registry = $Registry;
        /**
         * Need to instantiate Cache so that it
         * will listen to event and unset some keys
         */
        $this->Cache = $this->Registry->Cache;
        $this->Registry->registerObservers('INPUT_FILTERS');
    }


    /**
     * Getter for SubmittedAnswer
     *
     * @return object of type SubmittedAnswer
     */
    public function getSubmittedAnswer()
    {
        return $this->SubmittedAnswer;
    }


    /**
     * Getter for $this->Answer
     *
     * @return mixed object of type Answer or null
     * if answer object has not yet been created
     */
    public function getAnswer()
    {
        return $this->Answer;
    }


    /**
     * Main entry point to parse
     * submitted answer
     *
     * @param                        object SubmittedAnswer $o
     * @param \Lampcms\Question|null $q
     *
     * @internal param \Lampcms\Question $object $q represents the parent question
     *           this is optional, if not passed, this class will
     *           find parent question based on 'qid' from submitted answer
     *
     * @return object of type Answer representing the new
     *           answer (which is also MongoDoc ArrayObject)
     */
    public function parse(SubmittedAnswer $o, Question $q = null)
    {
        $this->SubmittedAnswer = $o;
        $this->Question        = (null !== $q) ? $q : $this->getQuestion();
        $this->makeAnswer();
        $this->followQuestion();

        return $this->Answer;
    }


    /**
     * Prepare array of data for the answer,
     * then create Answer object from it and
     * save. It will also fire onBeforeNewAnswer
     * and onNewAnswer events
     *
     * @throws AnswerParserException
     *
     * @return object $this
     */
    protected function makeAnswer()
    {

        /**
         * Must pass array('drop-proprietary-attributes' => false)
         * otherwise tidy removes rel="code"
         */
        $aEditorConfig = $this->Registry->Ini->getSection('EDITOR');
        $tidyConfig    = ($aEditorConfig['ENABLE_CODE_EDITOR']) ? array('drop-proprietary-attributes' => false) : null;
        $Body          = $this->SubmittedAnswer->getBody()->tidy($tidyConfig)->safeHtml()->asHtml();

        $HtmlDoc  = HTMLStringParser::stringFactory($Body)->parseCodeTags()->linkify()->importCDATA()->setNofollow()->parseImages();
        $aImages  = $HtmlDoc->getImages();
        $htmlBody = $HtmlDoc->valueOf();

        d('after HTMLStringParser: ' . $htmlBody);
        $Poster   = $this->SubmittedAnswer->getUserObject();
        $username = $Poster->getDisplayName();
        $uid      = $Poster->getUid();
        $qid      = $this->SubmittedAnswer->getQid();

        $hash = hash('md5', \mb_strtolower($htmlBody . $qid));

        /**
         *
         * We need to copy the title
         * here too because Answer by itself does not have own
         * title but we need a title when displaying links
         * to answer on profile pages
         *
         * @todo later can also parse for smilies here
         *
         */
        $this->checkForDuplicate($hash);

        $resourceStatus = ($Poster->isOnProbation()) ? Schema::PENDING : Schema::POSTED;

        $aData = array(
            Schema::PRIMARY                 => $this->Registry->Resource->create('ANSWER'),
            Schema::QUESTION_ID             => $qid,
            Schema::POSTER_ID               => $uid,
            Schema::QUESTION_OWNER_ID       => $this->Question->getOwnerId(),
            Schema::TITLE                   => $this->Question->getTitle(),
            Schema::BODY_HASH               => $hash,
            Schema::POSTER_USERNAME         => $username,
            Schema::USER_PROFILE_URL        => '<a href="' . $this->SubmittedAnswer->getUserObject()->getProfileUrl() . '">' . $username . '</a>',
            Schema::AVATAR_URL              => $this->SubmittedAnswer->getUserObject()->getAvatarSrc(),
            Schema::WORDS_COUNT             => $Body->asPlainText()->getWordsCount(),
            Schema::UPVOTES_COUNT           => 0,
            Schema::DOWNVOTES_COUNT         => 0,
            Schema::VOTES_SCORE             => 0,
            Schema::CATEGORY_ID             => $this->Question->getCategoryId(),
            Schema::BODY                    => $htmlBody,
            Schema::CREATED_TIMESTAMP       => time(),
            Schema::LAST_MODIFIED_TIMESTAMP => time(),
            Schema::TIME_STRING             => date('F j, Y g:i a T'),
            Schema::PLURAL_POSTFIX          => 's',
            Schema::IS_ACCEPTED             => false,
            Schema::IP_ADDRESS              => $this->SubmittedAnswer->getIP(),
            Schema::RESOURCE_STATUS_ID      => $resourceStatus,
            Schema::APP_NAME                => 'web'
        );

        if (!empty($aImages)) {
            $aData[Schema::UPLOADED_IMAGES] = $aImages;
        }

        /**
         * Submitted answer object may provide
         * extra elements to be added to aData array
         * This is usually useful for parsing answers that
         * came from external API
         *
         * as well as adding 'credit' div
         */
        $aExtraData = $this->SubmittedAnswer->getExtraData();
        d('$aExtraData: ' . print_r($aExtraData, 1));
        if (!empty($aExtraData)) {
            $aData = array_merge($aData, $aExtraData);
        }
        d('$aData: ' . print_r($aData, 1));

        $this->Answer = new Answer($this->Registry, $aData);

        /**
         * Post onBeforeNewQuestion event
         * and watch for filter either cancelling the event
         * or throwing FilterException (preferred way because
         * a specific error message can be passed in FilterException
         * this way)
         *
         * In either case we throw QuestionParserException
         * Controller that handles the question form should be ready
         * to handle this exception and set the form error using
         * message from exception. This way the error will be shown to
         * the user right on the question form while question form's data
         * is preserved in form.
         */
        try {
            $oNotification = $this->Registry->Dispatcher->post($this->Answer, 'onBeforeNewAnswer');
            if ($oNotification->isNotificationCancelled()) {
                throw new AnswerParserException('@@Sorry, we are unable to process your answer at this time@@');
            }
        } catch ( FilterException $e ) {
            e('Got filter exception: ' . $e->getFile() . ' ' . $e->getLine() . ' ' . $e->getMessage() . ' ' . $e->getTraceAsString());
            throw new AnswerParserException($e->getMessage());
        }

        /**
         * Do ensureIndexes() now and not before we are sure that we even going
         * to add a new question.
         */
        $this->ensureIndexes();

        $this->Answer->insert();
        d('cp');
        /**
         * post onCategoryUpdate only if status NOT PENDING
         */
        if ($resourceStatus !== Schema::PENDING) {
            $this->updateCategory();
            $this->updateQuestion();
            $this->Registry->Dispatcher->post($this->Question, 'onCategoryUpdate');
            $this->Registry->Dispatcher->post($this->Answer, 'onNewAnswer', array('question' => $this->Question));
        } elseif ($resourceStatus === Schema::PENDING) {
            $this->Registry->Dispatcher->post($this->Answer, 'onNewPendingAnswer');
        }

        d('cp');
        /**
         * Reuse $uid since we already resolved it here,
         * so no need to go through the same
         * $this->SubmittedAnswer->getUserObject()->getUid() again
         */
        $this->addUserTags($uid);
        d('cp');

        return $this;
    }


    /**
     * Ensure indexes in all collections involved
     * in storing question data
     *
     * @return object $this
     */
    protected function ensureIndexes()
    {
        $ans = $this->Registry->Mongo->ANSWERS;
        /**
         * There is no reason to index by original timestamp
         * (i_ts) because if we want to order by added time
         * we can just sort by _id since value
         * of _id in already in the order from oldest to newest
         * (which is a primary key and alwasy indexed anyway)
         */
        $ans->ensureIndex(array(Schema::LAST_MODIFIED_TIMESTAMP => 1));
        $ans->ensureIndex(array(Schema::VOTES_SCORE => 1));
        $ans->ensureIndex(array(Schema::POSTER_ID => 1));
        $ans->ensureIndex(array(Schema::QUESTION_ID => 1));
        $ans->ensureIndex(array(Schema::BODY_HASH => 1), array('unique' => true));
        /**
         * Index by ip address will help when we need to find
         * all posts from the same ip which we need for
         * flood check
         */
        $ans->ensureIndex(array(Schema::IP_ADDRESS => 1));

        return $this;
    }


    /**
     * Detect exact same answer submitted for same
     * question, regardless of who submitted the answer
     *
     * Even when submitted by 2 different users, duplicate answers
     * are not allowed
     *
     * @param $hash hash of the answer text
     *
     * @throws AnswerParserException
     * @return object $this
     */
    protected function checkForDuplicate($hash)
    {
        $a = $this->Registry->Mongo->ANSWERS->findOne(array(Schema::BODY_HASH => $hash));
        if (!empty($a)) {
            throw new AnswerParserException('@@Someone (possibly you) has already added exact same answer for this question. Duplicate answers are not allowed@@');
        }

        return $this;
    }


    /**
     * Increase answer count
     * for question.
     * Also set Last Answerer details
     * and add Answerer User to list
     * of Question contributors
     * (this is for the dot-folders feature)
     *
     * The increaseAnswerCount will also update
     * the last modified timestamp for question
     *
     * @return object $this
     */
    protected function updateQuestion()
    {
        d('cp');
        $User = $this->SubmittedAnswer->getUserObject();
        d('cp');
        $this->Question->updateAnswerCount();
        $this->Question->addContributor($User);
        $this->Question->setLatestAnswer($User, $this->Answer);
        $this->Question->touch();
        $this->Question->save();

        return $this;
    }

    protected function updateCategory()
    {
        $Updator = new \Lampcms\Category\Updator($this->Registry->Mongo);
        $Updator->addAnswer($this->Answer);

        return $this;
    }

    /**
     * Update Title of All Answers for particular question id
     *
     * @param int    $qid
     * @param string $title
     *
     * @return $this
     * @throws \InvalidArgumentException
     */
    public function updateTitle($qid, $title)
    {
        if (!is_int($qid)) {
            throw new \InvalidArgumentException('$qid must be an integer. Was: ' . gettype($qid));
        }

        $update = array('$set' => array(Schema::TITLE => $title));

        /**
         * multiple => true is necessary to update ALL answers that match question id
         */
        $this->Registry->Mongo->ANSWERS->update(array(Schema::QUESTION_ID => $qid), $update, array('multiple' => true));

        return $this;
    }


    /**
     * Answer author will automatically
     * start following this question
     *
     * @return object $this
     */
    protected function followQuestion()
    {
        $FollowManager = new FollowManager($this->Registry);
        $FollowManager->followQuestion($this->Registry->Viewer, $this->Question);

        return $this;
    }


    /**
     * Updates USER_TAGS collection
     * Takes into account the tags from the
     * Question for which the user just submitted
     * an answer.
     * This is run via shutdown function
     *
     * @param $uid
     *
     * @return object $this
     */
    protected function addUserTags($uid)
    {
        d('cp');
        $Tags = UserTags::factory($this->Registry);
        d('cp');
        $Question = $this->Question;
        d('cp');
        $func = function () use ($Tags, $uid, $Question) {
            $Tags->addTags($uid, $Question);
        };
        d('cp');
        runLater($func);
        d('cp');

        return $this;
    }


    /**
     * Getter for $this->Question
     *
     * @throws Exception
     * @return object of type Question representing the Question
     * for which we parsing the answer
     */
    public function getQuestion()
    {
        if (!isset($this->Question)) {
            $a = $this->Registry->Mongo->QUESTIONS->findOne(array(Schema::PRIMARY => $this->SubmittedAnswer->getQid()));

            if (empty($a)) {
                e('Cannot find question with _id: ' . $this->Answer['qid']);

                throw new Exception('@@Unable to find parent question for this answer@@');
            }

            $this->Question = new Question($this->Registry, $a);
        }

        return $this->Question;
    }

}

