<?php
/**
 *
 * License, TERMS and CONDITIONS
 *
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE (LGPL) version 3
 * Please read the license here : http://www.gnu.org/licenses/lgpl-3.0.txt
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * ATTRIBUTION REQUIRED
 * 4. All web pages generated by the use of this software, or at least
 *       the page that lists the recent questions (usually home page) must include
 *    a link to the http://www.lampcms.com and text of the link must indicate that
 *    the website's Questions/Answers functionality is powered by lampcms.com
 *    An example of acceptable link would be "Powered by <a href="http://www.lampcms.com">LampCMS</a>"
 *    The location of the link is not important, it can be in the footer of the page
 *    but it must not be hidden by style attributes
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE FREEBSD PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This product includes GeoLite data created by MaxMind,
 *  available from http://www.maxmind.com/
 *
 *
 * @author     Dmitri Snytkine <cms@lampcms.com>
 * @copyright  2005-2012 (or current year) Dmitri Snytkine
 * @license    http://www.gnu.org/licenses/lgpl-3.0.txt GNU LESSER GENERAL PUBLIC LICENSE (LGPL) version 3
 * @link       http://www.lampcms.com   Lampcms.com project
 * @version    Release: 0.2.45
 *
 *
 */

namespace Lampcms\Controllers;

use Lampcms\WebPage;
use Lampcms\String;
use \Lampcms\Mongo\Schema\User as Schema;


/**
 * Class responsible for
 * displaying the forgot password
 * form, processing the form,
 * generating a new random password
 * for user
 * and emailing it to user
 */
class Remindpwd extends WebPage
{
    protected $layoutID = 1;

    /**
     * @var object of type Form
     */
    protected $Form;

    protected $aAllowedVars = array('login');


    /**
     *
     * Username or email address
     * submitted in forgotten password form
     *
     * @var string
     */
    protected $login;

    /**
     * User ID of user who forgot password
     *
     * @var int
     */
    protected $uid;


    /**
     * The user was found by email
     * and not by username
     *
     * @var bool
     */
    protected $byEmail = false;


    /**
     *
     * Email address of user
     *
     * @var string
     */
    protected $emailAddress;

    /**
     *
     * Secret string will be used in reset
     * password link, sent to user via email
     *
     * @var string
     */
    protected $randomString;


    /**
     * Renders and processes the form
     *
     * @return string page with html form
     * @internal param array $arrParams array of GET or POST params
     */
    protected function main()
    {

        $this->title = '@@Password help@@';

        $this->Form               = new \Lampcms\Forms\Pwd($this->Registry);
        $this->aPageVars['title'] = $this->title;


        if ($this->Form->isSubmitted() && $this->Form->validate() && $this->validateUser()) {
            d('cp');
            $this->generateCode()->emailCode();
            $this->aPageVars['body'] = '<div class="frm1">'.$this->Registry->Tr->get('password_request.success', array('{username}' => $this->login)).'</div>';
        } else {
            $this->aPageVars['body'] = $this->Form->getForm();
        }
    }


    /**
     * Validation to check that user
     * with this username or email address
     * exists in the database
     * If user exists, set the $this->forgottenUid
     * to the value of this user's id
     *
     * @throws \Lampcms\Exception
     * @return bool true if user found, otherwise false
     */
    protected function validateUser()
    {
        $this->login = \mb_strtolower($this->Form->getSubmittedValue('login'));
        d('$this->login: ' . $this->login);
        if (false !== \filter_var($this->login, FILTER_VALIDATE_EMAIL)) {
            d('cp');
            $this->byEmail = true;
            $aEmail        = $this->Registry->Mongo->EMAILS->findOne(array(Schema::EMAIL => $this->login));
            if (empty($aEmail)) {
                $this->Form->setError('login', '@@No user with this email address@@');

                return false;
            }

            d('$aEmail: ' . print_r($aEmail, 1));
            $aResult = $this->Registry->Mongo->USERS->findOne(array(Schema::PRIMARY => (int)$aEmail['i_uid']));

        } else {
            if (false === \Lampcms\Validate::username($this->login)) {
                d('cp');
                $this->Form->setError('login', '@@This username is invalid@@');

                return false;
            }

            $aResult = $this->Registry->Mongo->USERS->findOne(array(Schema::USERNAME_LOWERCASE => $this->login));
        }

        if (empty($aResult)) {
            d('cp');

            $this->Form->setError('login', '@@User Not found@@');

            return false;
        }


        /**
         * @todo
         *
         * if 'usertype' == 'email'
         * then user does not have login
         * Just test and then throw an exception?
         * Actually maybe it's better if user could just login
         * then edit profile and become regular user...
         *
         * But how would we do that? We would basically activate
         * a user on first login.
         */
        d('$aResult: ' . \json_encode($aResult));

        /**
         * If username exists but email does not
         * such as the case when user is external user who has
         * not yet provided email address
         *
         */

        if (empty($aResult['email'])) {
            throw new \Lampcms\Exception('@@This is an external account and you have not provided a valid email address for it@@');
        }

        /**
         * If user does not have username
         * then we should use email address instead
         * user should be able to login using email address!
         *
         */
        $this->uid          = $aResult['_id'];
        $this->login        = (!empty($aResult['username'])) ? $aResult['username'] : $aResult['email'];
        $this->emailAddress = $aResult['email'];

        return true;
    }


    /**
     * Generates a random string
     * to be use in password reset url
     * It checks to make sure this string does not already exist
     * in the PASSWORD_CHANGE table
     *
     * @throws \Lampcms\Exception
     * @return \Lampcms\Controllers\object $this
     */
    protected function generateCode()
    {
        d('cp');
        $counter = 0;
        $done    = false;

        do {
            $counter++;
            $aData          = array();
            $aData['_id']   = \strtolower(\Lampcms\String::makeRandomString(12));
            $aData['i_ts']  = time();
            $aData['i_uid'] = $this->uid;

            /**
             * @todo
             * Don't use _id for string,
             * instead use unique index on string + 'y'/'n' value of 'used'
             * This way string can be duplicate as long as no same
             * string is used
             */
            try {
                $coll = $this->Registry->Mongo->PASSWORD_CHANGE;
                $coll->insert($aData, array('fsync' => true));
                $done = true;
                d('cp');
            } catch ( \MongoException $e ) {
                d('code already exists, trying again...');
            }

        } while (!$done && ($counter < 50));

        if (!$done) {
            throw new \Lampcms\Exception('@@Unable to generate random string at this time, please try again in 30 seconds@@');
        }

        $this->randomString = $aData['_id'];

        return $this;
    }


    /**
     * Prepares the body, subject and from
     * and email to user
     *
     * of this class
     *
     * @return object $this
     */
    protected function emailCode()
    {
        $Tr             = $this->Registry->Tr;
        $routerCallback = $this->Registry->Router->getCallback();
        $uri            = $routerCallback('{_WEB_ROOT_}/{_resetpwd_}');
        d('uri: ' . $uri);


        $link = $this->Registry->Ini->SITE_URL . $uri . '/' . $this->uid . '/' . $this->randomString;
        print_r($link);
        $body = $Tr->get('email.body.password_request', array(
                '{username}'   => $this->login,
                '{site_title}' => $this->Registry->Ini->SITE_NAME,
                '{link}'       => $link)
        );

        print_r($body);
        $subject = $Tr->get('email.subject.password_request', array('{site_title}' => $this->Registry->Ini->SITE_NAME));
        d('subject: '.$subject);

        $this->Registry->Mailer->mail($this->emailAddress, $subject, $body);

        return $this;
    }

}
