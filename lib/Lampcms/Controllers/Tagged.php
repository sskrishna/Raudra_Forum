<?php
/**
 *
 * License, TERMS and CONDITIONS
 *
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE (LGPL) version 3
 * Please read the license here : http://www.gnu.org/licenses/lgpl-3.0.txt
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * ATTRIBUTION REQUIRED
 * 4. All web pages generated by the use of this software, or at least
 *       the page that lists the recent questions (usually home page) must include
 *    a link to the http://www.lampcms.com and text of the link must indicate that
 *    the website's Questions/Answers functionality is powered by lampcms.com
 *    An example of acceptable link would be "Powered by <a href="http://www.lampcms.com">LampCMS</a>"
 *    The location of the link is not important, it can be in the footer of the page
 *    but it must not be hidden by style attributes
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE FREEBSD PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This product includes GeoLite data created by MaxMind,
 *  available from http://www.maxmind.com/
 *
 *
 * @author     Dmitri Snytkine <cms@lampcms.com>
 * @copyright  2005-2012 (or current year) Dmitri Snytkine
 * @license    http://www.gnu.org/licenses/lgpl-3.0.txt GNU LESSER GENERAL PUBLIC LICENSE (LGPL) version 3
 * @link       http://www.lampcms.com   Lampcms.com project
 * @version    Release: 0.2.45
 *
 *
 */

namespace Lampcms\Controllers;

use \Lampcms\RedirectException;
use \Lampcms\Relatedtags;
use \Lampcms\Mongo\Schema\Question as Schema;

/**
 * Controller for rendering page
 * with list of questions for specific tag or tags
 *
 *
 * @author Dmitri Snytkine
 *
 */
class Tagged extends Unanswered
{

    /**
     * Indicates the current tab
     *
     * @var string
     */
    protected $qtab = 'questions';

    /**
     * Overrides the use of $this->Router->getRealPageID
     * because we don't want a possibility of
     * extracting pageID from a tag name when a tag contains number
     *
     * @return object $this
     */
    public function setPageID()
    {
        $this->pageID = (int)$this->Router->getPageID();

        return $this;
    }

    /**
     * Select items according to conditions passed in GET
     * Conditions can be == 'unanswered', 'hot', 'recent' (default)
     *
     * @throws \Lampcms\RedirectException
     * @return \Lampcms\Controllers\Tagged
     */
    protected function getCursor()
    {

        /**
         * Must call getTags() before
         * using this->rawTags because
         * it is set inside the getTags() method
         *
         *
         */
        $this->aTags = $this->getTags();

        if (!isset($this->aTags)) {
            d('Tags not found in request: ' . $_SERVER['REQUEST_URI']);
            /**
             * No tags passed in url
             * just redirect to view all tags
             *
             */

            throw new RedirectException("{_WEB_ROOT_}/{_viewqtags_}/");
        }

        $this->pagerPath = '{_tagged_}/' . $this->rawTags;
        d('aTags: ' . print_r($this->aTags, 1));

        $cond = $this->Request->get('cond', 's', 'recent');

        /**
         * Default sort is by timestamp Descending
         * meaning most recent should be on top
         *
         */
        $sort = array(Schema::CREATED_TIMESTAMP => -1);

        $where = array(Schema::TAGS_ARRAY => array('$all' => $this->aTags));
        /**
         * Exclude deleted items
         */
        if ($this->Registry->Viewer->isModerator()) {
            $where[Schema::RESOURCE_STATUS_ID] = array('$lt' => Schema::DELETED);
        } else {
            $where[Schema::RESOURCE_STATUS_ID] = Schema::POSTED;
        }

        $replaced = array(
            'tags' => \str_replace(' ', ' + ', $this->tags),
            'text' => '@@Tagged@@'
        );

        $this->counterTaggedText = \tplCounterblocksub::parse($replaced, false);

        $this->Cursor = $this->Registry->Mongo->QUESTIONS->find($where, $this->aFields);
        $this->count = $this->Cursor->count(true);
        $this->Cursor->sort($sort);

        return $this;
    }


    protected function makeRecentTags()
    {

        /**
         * @todo
         * Currently we are finding related tags for just one tag
         * This is very fast because we store related tags pre-parsed
         * as html string. This works and looks good but...
         * If we really wanted this to work just like
         * on stackoverflow then we have to change it to this:
         * if there is only one tag passed in URL, then use this method
         * otherwise do this:
         * Use find() on RELATED_TAGS collection and pass $this->aTags
         * as $all condition. This will find all records in RELATED_TAGS
         * that have all these tags. Then we have result cursor from which
         * we are only interested in _id value which is the actual tag related
         * to all our tags.
         * We would then loop over cursor and pass
         * each array to tplRelatedlink, passing each _id
         * as value of 'tag' and prepend +tag to $this->rawTags as
         * value of 'link'
         *
         * This will be slower than just using pre-parsed related tags
         * but it will be exactly like on Stackoverflow
         *
         * For this to work we need to ensureIndex on 'tags' in RELATED_TAGS
         * collection!
         */
        $tag = end($this->aTags);
        d('tag: ' . $tag);

        $s = Relatedtags::factory($this->Registry)->getHtml($tag);

        if (!empty($s)) {
            $tags = \tplBoxrecent::parse(array('tags' => $s, 'title' => '@@Related Tags@@'));
            $this->aPageVars['tags'] = $tags;
        }

        $this->makeFollowTagButton();

        return $this;
    }

}

